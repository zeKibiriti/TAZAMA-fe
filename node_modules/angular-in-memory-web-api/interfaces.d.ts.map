{"version":3,"file":"interfaces.d.ts","sources":["D:/PROJECTS/TAZAMA/oprt-fe/node_modules/angular-in-memory-web-api/interfaces.d.ts"],"sourcesContent":["import { Observable } from 'rxjs';\n/**\n *  Minimum definition needed by base class\n */\nexport interface HeadersCore {\n    set(name: string, value: string): void | any;\n}\n/**\n* Interface for a class that creates an in-memory database\n*\n* Its `createDb` method creates a hash of named collections that represents the database\n*\n* For maximum flexibility, the service may define HTTP method overrides.\n* Such methods must match the spelling of an HTTP method in lower case (e.g, \"get\").\n* If a request has a matching method, it will be called as in\n* `get(info: requestInfo, db: {})` where `db` is the database object described above.\n*/\nexport declare abstract class InMemoryDbService {\n    /**\n    * Creates an in-memory \"database\" hash whose keys are collection names\n    * and whose values are arrays of collection objects to return or update.\n    *\n    * returns Observable of the database because could have to create it asynchronously.\n    *\n    * This method must be safe to call repeatedly.\n    * Each time it should return a new object with new arrays containing new item objects.\n    * This condition allows the in-memory backend service to mutate the collections\n    * and their items without touching the original source data.\n    *\n    * The in-mem backend service calls this method without a value the first time.\n    * The service calls it with the `RequestInfo` when it receives a POST `commands/resetDb` request.\n    * Your InMemoryDbService can adjust its behavior accordingly.\n    */\n    abstract createDb(reqInfo?: RequestInfo): {} | Observable<{}> | Promise<{}>;\n}\n/**\n* Interface for InMemoryBackend configuration options\n*/\nexport declare abstract class InMemoryBackendConfigArgs {\n    /**\n     * The base path to the api, e.g, 'api/'.\n     * If not specified than `parseRequestUrl` assumes it is the first path segment in the request.\n     */\n    apiBase?: string;\n    /**\n     * false (default) if search match should be case insensitive\n     */\n    caseSensitiveSearch?: boolean;\n    /**\n     * false (default) put content directly inside the response body.\n     * true: encapsulate content in a `data` property inside the response body, `{ data: ... }`.\n     */\n    dataEncapsulation?: boolean;\n    /**\n     * delay (in ms) to simulate latency\n     */\n    delay?: number;\n    /**\n     * false (default) should 204 when object-to-delete not found; true: 404\n     */\n    delete404?: boolean;\n    /**\n     * host for this service, e.g., 'localhost'\n     */\n    host?: string;\n    /**\n     * false (default) should pass unrecognized request URL through to original backend; true: 404\n     */\n    passThruUnknownUrl?: boolean;\n    /**\n     * true (default) should NOT return the item (204) after a POST. false: return the item (200).\n     */\n    post204?: boolean;\n    /**\n    * false (default) should NOT update existing item with POST. false: OK to update.\n    */\n    post409?: boolean;\n    /**\n    * true (default) should NOT return the item (204) after a POST. false: return the item (200).\n    */\n    put204?: boolean;\n    /**\n     * false (default) if item not found, create as new item; false: should 404.\n     */\n    put404?: boolean;\n    /**\n     * root path _before_ any API call, e.g., ''\n     */\n    rootPath?: string;\n}\n/**\n*  InMemoryBackendService configuration options\n*  Usage:\n*    InMemoryWebApiModule.forRoot(InMemHeroService, {delay: 600})\n*\n*  or if providing separately:\n*    provide(InMemoryBackendConfig, {useValue: {delay: 600}}),\n*/\nexport declare class InMemoryBackendConfig implements InMemoryBackendConfigArgs {\n    constructor(config?: InMemoryBackendConfigArgs);\n}\n/** Return information (UriInfo) about a URI  */\nexport declare function parseUri(str: string): UriInfo;\n/**\n *\n * Interface for the result of the `parseRequestUrl` method:\n *   Given URL \"http://localhost:8080/api/customers/42?foo=1 the default implementation returns\n *     base: 'api/'\n *     collectionName: 'customers'\n *     id: '42'\n *     query: this.createQuery('foo=1')\n *     resourceUrl: 'http://localhost/api/customers/'\n */\nexport interface ParsedRequestUrl {\n    apiBase: string;\n    collectionName: string;\n    id: string;\n    query: Map<string, string[]>;\n    resourceUrl: string;\n}\nexport interface PassThruBackend {\n    /**\n     * Handle an HTTP request and return an Observable of HTTP response\n     * Both the request type and the response type are determined by the supporting HTTP library.\n     */\n    handle(req: any): Observable<any>;\n}\nexport declare function removeTrailingSlash(path: string): string;\n/**\n *  Minimum definition needed by base class\n */\nexport interface RequestCore {\n    url: string;\n    urlWithParams?: string;\n}\n/**\n* Interface for object w/ info about the current request url\n* extracted from an Http Request.\n* Also holds utility methods and configuration data from this service\n*/\nexport interface RequestInfo {\n    req: RequestCore;\n    apiBase: string;\n    collectionName: string;\n    collection: any;\n    headers: HeadersCore;\n    method: string;\n    id: any;\n    query: Map<string, string[]>;\n    resourceUrl: string;\n    url: string;\n    utils: RequestInfoUtilities;\n}\n/**\n * Interface for utility methods from this service instance.\n * Useful within an HTTP method override\n */\nexport interface RequestInfoUtilities {\n    /**\n     * Create a cold response Observable from a factory for ResponseOptions\n     * the same way that the in-mem backend service does.\n     * @param resOptionsFactory - creates ResponseOptions when observable is subscribed\n     * @param withDelay - if true (default), add simulated latency delay from configuration\n     */\n    createResponse$: (resOptionsFactory: () => ResponseOptions) => Observable<any>;\n    /**\n     * Find first instance of item in collection by `item.id`\n     * @param collection\n     * @param id\n     */\n    findById<T extends {\n        id: any;\n    }>(collection: T[], id: any): T;\n    /** return the current, active configuration which is a blend of defaults and overrides */\n    getConfig(): InMemoryBackendConfigArgs;\n    /** Get the in-mem service's copy of the \"database\" */\n    getDb(): {};\n    /** Get JSON body from the request object */\n    getJsonBody(req: any): any;\n    /** Get location info from a url, even on server where `document` is not defined */\n    getLocation(url: string): UriInfo;\n    /** Get (or create) the \"real\" backend */\n    getPassThruBackend(): PassThruBackend;\n    /**\n     * return true if can determine that the collection's `item.id` is a number\n     * */\n    isCollectionIdNumeric<T extends {\n        id: any;\n    }>(collection: T[], collectionName: string): boolean;\n    /**\n     * Parses the request URL into a `ParsedRequestUrl` object.\n     * Parsing depends upon certain values of `config`: `apiBase`, `host`, and `urlRoot`.\n     */\n    parseRequestUrl(url: string): ParsedRequestUrl;\n}\n/**\n * Provide a `responseInterceptor` method of this type in your `inMemDbService` to\n * morph the response options created in the `collectionHandler`.\n */\nexport declare type ResponseInterceptor = (res: ResponseOptions, ri: RequestInfo) => ResponseOptions;\nexport interface ResponseOptions {\n    /**\n     * String, Object, ArrayBuffer or Blob representing the body of the {@link Response}.\n     */\n    body?: string | Object | ArrayBuffer | Blob;\n    /**\n     * Response headers\n     */\n    headers?: HeadersCore;\n    /**\n     * Http {@link http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html status code}\n     * associated with the response.\n     */\n    status?: number;\n    /**\n     * Status text for the status code\n     */\n    statusText?: string;\n    /**\n     * request url\n     */\n    url?: string;\n}\n/** Interface of information about a Uri  */\nexport interface UriInfo {\n    source: string;\n    protocol: string;\n    authority: string;\n    userInfo: string;\n    user: string;\n    password: string;\n    host: string;\n    port: string;\n    relative: string;\n    path: string;\n    directory: string;\n    file: string;\n    query: string;\n    anchor: string;\n}\n"],"names":[],"mappings":"AAAA;;;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}